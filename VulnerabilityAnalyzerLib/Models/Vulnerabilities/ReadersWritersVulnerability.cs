

using System.Collections.Generic;
using System.Text.RegularExpressions;

namespace VulnerabilityAnalyzerLib.Models.Vulnerabilities
{
    public class ReadersWritersVulnerability : Vulnerability
    {
        public ReadersWritersVulnerability()
        {
            Name = "Readers-Writers vulnerability";
            InitializePatterns();
        }

        private void InitializePatterns()
        {
            Patterns = new();


            Patterns.Add((src) =>
            {
                var lines = new List<SourceLine>();
                
                var globalVars = findGlobalVars(src.Lines);
                var threadedFuncs = findThreadedFunc(src.Lines);

                foreach (var threadedFunc in threadedFuncs)
                {
                    var mutexLocked = false;
                    var funcContent = findFuncContent(src.Lines, threadedFunc);
                    foreach (var funcLine in funcContent)
                    {
                        if (new Regex(@"lock\(.*\)").Match(funcLine.Line).Success)
                        {
                            mutexLocked = true;
                        }
                        if (new Regex(@"unlock\(.*\)").Match(funcLine.Line).Success)
                        {
                            mutexLocked = false;
                        }

                        foreach (var globalVar in globalVars)
                        {
                            var regex = new Regex(@"\b" + globalVar + @"\b");
                            var globalVarInLine = regex.Match(funcLine.Line);
                            if (globalVarInLine.Success)
                            {
                                if (!mutexLocked)
                                {
                                    lines.Add(funcLine);
                                }
                            }
                        }
                    }
                }

                return lines;
            });
        }

        internal List<string> findGlobalVars(List<SourceLine> srcLines)
        {
            var varDeclarationPatterns = new List<string>(){
                        @"\bint\s+(\w+)\s*[=|;]",
                        @"\bchar.*\s+(\w+)\s*[=|;]",
                        @"\bfloat\s+(\w+)\s*[=|;]",
                        @"\bdouble\s+(\w+)\s*[=|;]",
                    };
            var localScopeBegginingPattern = @"^[\w\s\*]+\([\w\s\*,!=]*\)";
            var localScopeEndingPattern = @"\}$";
            var localScopeNestedLevel = 0;
            var globalVars = new List<string>();

            foreach (var line in srcLines)
            {
                var regex = new Regex(localScopeBegginingPattern);
                var foundLocalScopeBeggining = regex.Match(line.Line);
                if (foundLocalScopeBeggining.Success)
                {
                    localScopeNestedLevel += 1;
                    continue;
                }
                else
                {
                    regex = new Regex(localScopeEndingPattern);
                    var foundLocalScopeEnding = regex.Match(line.Line);
                    if (foundLocalScopeEnding.Success)
                    {
                        localScopeNestedLevel -= 1;
                        continue;
                    }
                    if (localScopeNestedLevel == 0)
                    {
                        foreach (var varDeclarationPattern in varDeclarationPatterns)
                        {

                            regex = new Regex(varDeclarationPattern);
                            Match match = regex.Match(line.Line);
                            if (match.Success)
                            {
                                globalVars.Add(match.Groups[1].Value);
                            }
                        }
                    }
                }
            }
            return globalVars;
        }

        internal List<string> findThreadedFunc(List<SourceLine> srcLines)
        {
            var threadedFuncs = new List<string>();
            var pattern = @"\bthread\b\s*.*\s*\((\w.*)\).*";
            foreach(var line in srcLines)
            {
                var regex = new Regex(pattern);
                Match match = regex.Match(line.Line);
                if (match.Success)
                {
                    threadedFuncs.Add(match.Groups[1].Value);
                }
            }
            return threadedFuncs;
        }

        internal List<SourceLine> findFuncContent(List<SourceLine> srcLines, string funcName)
        {
            var result = new List<SourceLine>();
            var funcBegginingPattern = @"^[\w\s\*]+" + funcName + @"\s*\(";
            var localScopeEndingPattern = @"\}$";
            var localScopeNestedLevel = 0;
            var lastIteration = false;
            foreach (var line in srcLines)
            {
                if (lastIteration)
                {
                    result.Add(line);
                    break;
                }
                var regex = new Regex(funcBegginingPattern);
                var foundLocalScopeBeggining = regex.Match(line.Line);
                if (foundLocalScopeBeggining.Success)
                {
                    localScopeNestedLevel += 1;
                    result.Add(line);
                    continue;
                }
                else if (localScopeNestedLevel != 0)
                {
                    regex = new Regex(localScopeEndingPattern);
                    var foundLocalScopeEnding = regex.Match(line.Line);
                    if (foundLocalScopeEnding.Success)
                    {
                        localScopeNestedLevel -= 1;                    
                    }
                    result.Add(line);
                    if (localScopeNestedLevel == 0)
                    {
                        lastIteration = true;
                        continue;
                    }
                }
                
            }
            return result;
        }
    }
}
