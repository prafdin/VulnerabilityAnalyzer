using CommandLine;
using Stimulsoft.Report.Export;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace VulnerabilityAnalyzerLib.Models.Vulnerabilities
{
    public class IncorrectFileAccessVulnerability : Vulnerability
    {
        public IncorrectFileAccessVulnerability()
        {
            Name = "Incorrect File Access vulnerability";
            InitializePatterns();
        }

        private void InitializePatterns()
        {
            Patterns = new ();

            Patterns.Add(src => { return IsAccessingClosedFile(src); });
            Patterns.Add(src => { return IsWritingToReadFile(src); });
            Patterns.Add(src => { return IsMissingFileOpenCheck(src); });
        }

        private List<SourceLine> IsAccessingClosedFile(SourceText src)
        {
            // Проверка на работу с закрытым файлом
            var patternsForOpenFiles = new List<string>()
            {
                @"\s*fstream\b\s*(\w*).*;",
                @"\b(\w*)\s*=\s*fopen\b"
            };

            var varNameCreateStream = new List<string>();
            foreach (var line in src.Lines)
            {
                foreach (var pattern in patternsForOpenFiles)
                {
                    var regex = new Regex(pattern);
                    Match match = regex.Match(line.Line);
                    if (match.Success)
                    {
                        varNameCreateStream.Add(match.Groups[1].Value);
                    }
                }
            }

            var linesWithCloseFiles = new List<SourceLine>();
            foreach (var line in src.Lines)
            {
                foreach(var variable in varNameCreateStream)
                {
                    var patternsForCloseFiles = new List<string>()
                    {
                        $@"\bfclose\s*\({variable}",
                        $@"\s*{variable}\.close"
                    };
                    foreach(var pattern in patternsForCloseFiles)
                    {
                        var regex = new Regex(pattern);
                        Match match = regex.Match(line.Line);
                        if (match.Success)
                        {
                            linesWithCloseFiles.Add(line);
                        }
                    }
                }
            }

            var lines = new List<SourceLine>();
            foreach (var line in src.Lines)
            {
                foreach(var variable in varNameCreateStream)
                {
                    var pattern = $@"\b{variable}\b";
                    var regex = new Regex(pattern);
                    var match = regex.Match(line.Line);
                    if (match.Success)
                    {
                        foreach(var lineWuthCloseFile in linesWithCloseFiles)
                        {
                            if(src.Lines[line.LineNumber-1] == lineWuthCloseFile)
                            {
                                lines.Add(line);
                            }
                        }
                    }
                }
            }
                
            return lines;
        }

        private List<SourceLine> IsWritingToReadFile(SourceText src)
        {
            // Проверка на запись в файл, открытый на read
            var patternsForReadFiles = new List<string>()
            {
                @"\bifstream\b\s*(\w*)",
                @"\b(\w*)\s*=\s*fopen\s*\(.*[r|rb]"
            };

            var varNameWithRead = new List<string>();
            foreach(var line in src.Lines)
            {
                foreach(var patternForReadFiles in patternsForReadFiles)
                {
                    var regex = new Regex(patternForReadFiles);
                    Match match = regex.Match(line.Line);
                    if (match.Success)
                    {
                        varNameWithRead.Add(match.Groups[1].Value);
                    }
                }
            }

            var lines = new List<SourceLine>();
            foreach(var line in src.Lines)
            {
                foreach(var variable in varNameWithRead)
                {
                    var patternsForWriteFile = new List<string>()
                    {
                        $@"\b{variable}\s*<<",
                        $@"\b{variable}.write\s*\(",
                        $@"\bfputs\s*\(.*,\s*{variable}",
                        $@"\bfprintf\s*\(\s*{variable}",
                    };
                    foreach(var pattern in patternsForWriteFile)
                    {
                        var regex = new Regex(pattern);
                        Match match = regex.Match(line.Line);
                        if (match.Success)
                        {
                            lines.Add(line);
                        }
                    }
                }
            }

            return lines;
        }

        private List<SourceLine> IsMissingFileOpenCheck(SourceText src)
        {
            // Проверка на отсутствие проверки открытия файла
            var patternsForOpenFiles = new List<string>()
            {
                @"\s*fstream\b\s*(\w+)",
                @"\b(\w*)\s*=\s*fopen\s*\(.*[r|rb]"
            };

            var linesWithVars = new Dictionary<string, SourceLine>();
            var varNameCreateStream = new List<string>();
            foreach(var line in src.Lines)
            {
                foreach(var pattern in patternsForOpenFiles)
                {
                    var regex = new Regex(pattern);
                    Match match = regex.Match(line.Line);
                    if (match.Success)
                    {
                        linesWithVars.Add(match.Groups[1].Value, line);
                        varNameCreateStream.Add(match.Groups[1].Value);
                    }
                }
            }

            foreach(var line in src.Lines)
            {
                foreach(var variable in varNameCreateStream)
                {
                    var patterns = new List<string>()
                    {
                        $@"\bif\s*.*{variable}\s*.*null",
                        $@"\bif\s*.*{variable}.is_open"
                    };
                    foreach(var pattern in patterns)
                    {
                        var regex = new Regex(pattern, RegexOptions.IgnoreCase);
                        Match match = regex.Match(line.Line);
                        if (match.Success)
                        {
                            linesWithVars.Remove(variable);
                        }
                    }
                }
            }

            var lines = new List<SourceLine>(linesWithVars.Values);

            return lines;
        }
    }
}
