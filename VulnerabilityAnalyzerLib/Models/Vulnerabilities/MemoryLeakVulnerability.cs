using System.Collections.Generic;
using System.Text.RegularExpressions;
using static Stimulsoft.Report.Export.DeflaterHuffman;

namespace VulnerabilityAnalyzerLib.Models.Vulnerabilities
{
    public class MemoryLeakVulnerability: Vulnerability
    {
        public MemoryLeakVulnerability()
        {
            Name = "Memory Leak Vulnerability";
            InitializePatterns();
        }

        public void InitializePatterns()
        {
            Patterns = new();

            Patterns.Add((src) =>
            {
                var memAllocationFunctions = new List<string>()
                {
                     @".*malloc\s*\(.*",
                     @".*calloc\s*\(.*",
                     @".*realloc\s*\(.*",
                     @".*\s*new\s*.*"
                };

                var memFreeFunctions = new List<string>()
                {
                    @".*free\s*\(.*",
                    @".*delete.*"
                };

                var namesVariables = new List<string>();
                foreach(var line in src.Lines)
                {
                    var patternForVariable = @"\*\s*([a-zA-Z0-9])";
                    var regex = new Regex(patternForVariable);
                    Match match = regex.Match(line.Line);
                    if (match.Success)
                    {
                        namesVariables.Add(match.Groups[1].Value);
                    }
                }

                var linesWithAllocationFunctions = new List<SourceLine>();
                foreach(var line in src.Lines)
                {
                    foreach(var memAllocationFunction in memAllocationFunctions)
                    {
                        var regex = new Regex(memAllocationFunction);
                        Match match = regex.Match(line.Line);
                        if(match.Success)
                        {
                            linesWithAllocationFunctions.Add(line);
                        }
                    }
                }

                var linesWithPointerOnAllocatedMemory = new Dictionary<string, SourceLine>();
                foreach(var line in linesWithAllocationFunctions)
                {
                    foreach(var variable in namesVariables)
                    {
                        var pattern = $@".*\s*{variable}\s*=";
                        var regex = new Regex(pattern);
                        Match match = regex.Match(line.Line);
                        if (match.Success)
                        {
                            linesWithPointerOnAllocatedMemory.Add(variable, line);
                        }
                    }
                }

                var linesWithFreeMemory = new List<SourceLine>();
                foreach (var line in src.Lines)
                {
                    foreach(var memFreeFunction in memFreeFunctions)
                    {
                        var regex = new Regex(memFreeFunction);
                        Match match = regex.Match(line.Line);
                        if(match.Success)
                        {
                            linesWithFreeMemory.Add(line);
                        }
                    }
                }

                var dangerLines = new List<SourceLine>();
                foreach(var line in linesWithFreeMemory)
                {
                    foreach(var variable in namesVariables)
                    {
                        var pattern1 = $@"free\s*\(\s*{variable}";
                        var pattern2 = $@"delete.*\s*{variable}";
                        var regex1 = new Regex(pattern1);
                        var regex2 = new Regex(pattern2);
                        Match match1 = regex1.Match(line.Line);
                        Match match2 = regex2.Match(line.Line);
                        if(match1.Success || match2.Success)
                        {
                            linesWithPointerOnAllocatedMemory.Remove(variable);
                        }
                    }
                }

                var lines = new List<SourceLine>(linesWithPointerOnAllocatedMemory.Values);

                foreach(var line in linesWithAllocationFunctions)
                {
                    var pattern = @"\s*new";
                    var regex = new Regex(pattern);
                    Match match = regex.Match(line.Line);
                    if (match.Success)
                    {
                        lines.Add(line);
                    }
                }

                return lines;
            });
        }
    }
}
