using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using VulnerabilityAnalyzerLib.Models.Vulnerabilities;
using VulnerabilityAnalyzerLib.Utils;
using Xunit;

namespace VulnerabilityAnalyzerLib.Tests.Models.Vulnerabilities
{    
    public class ReadersWritersVulnerabilityTests
    {
        static string ResourceRootDir = "./Resources/ReadersWritersSamples";
        SourceTextReader SourceTextReader { get; }
        ReadersWritersVulnerability Vulnerability { get; }

        public ReadersWritersVulnerabilityTests()
        {
            SourceTextReader = new SourceTextReader();
            Vulnerability = new ReadersWritersVulnerability();
        }

        [Fact]
        public async void CheckFunc_findGlobalVars()
        {
            var fileName = "01.cpp";
            var filePath = $"{ResourceRootDir}/{fileName}";
            await SourceTextReader.ReadFromFile(filePath);
            var sourceText = SourceTextReader.SourceTexts.First(s => s.FilePath == filePath);

            var globalVars = Vulnerability.findGlobalVars(sourceText.Lines);

            

            Assert.Single(globalVars);
            Assert.Contains(globalVars, globalVar => globalVar == "Z");
        }

        [Fact]
        public async void CheckFunc_findThreadedFunc()
        {
            var fileName = "01.cpp";
            var filePath = $"{ResourceRootDir}/{fileName}";
            await SourceTextReader.ReadFromFile(filePath);
            var sourceText = SourceTextReader.SourceTexts.First(s => s.FilePath == filePath);

            var threadedFunc = Vulnerability.findThreadedFunc(sourceText.Lines);



            Assert.Equal(2, threadedFunc.Count);
            Assert.Contains(threadedFunc, globalVar => globalVar == "read");
            Assert.Contains(threadedFunc, globalVar => globalVar == "write");
        }

        [Fact]
        public async void CheckFunc_findFuncContent()
        {
            var fileName = "01.cpp";
            var filePath = $"{ResourceRootDir}/{fileName}";
            await SourceTextReader.ReadFromFile(filePath);
            var sourceText = SourceTextReader.SourceTexts.First(s => s.FilePath == filePath);

            var funcContent = Vulnerability.findFuncContent(sourceText.Lines, "read");



            Assert.Equal(9, funcContent.Count);
        }

        [Fact]
        public async void ApplyPatternsTo_01()
        {
            var fileName = "01.cpp";
            var filePath = $"{ResourceRootDir}/{fileName}";
            await SourceTextReader.ReadFromFile(filePath);
            var sourceText = SourceTextReader.SourceTexts.First(s => s.FilePath == filePath);

            var foundLines = Vulnerability.ApplyPatterns(sourceText);

            Assert.Equal(4, foundLines.Count);
            Assert.Contains(foundLines, f => f.LineNumber == 11);
            Assert.Contains(foundLines, f => f.LineNumber == 13);
            Assert.Contains(foundLines, f => f.LineNumber == 22);
            Assert.Contains(foundLines, f => f.LineNumber == 24);
        }

        [Fact]
        public async void ApplyPatternsTo_02()
        {
            var fileName = "02.cpp";
            var filePath = $"{ResourceRootDir}/{fileName}";
            await SourceTextReader.ReadFromFile(filePath);
            var sourceText = SourceTextReader.SourceTexts.First(s => s.FilePath == filePath);

            var foundLines = Vulnerability.ApplyPatterns(sourceText);

            Assert.Empty(foundLines);
        }
    }
}
